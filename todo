* Trie
    * [ ] Fix failing tests
    * [ ] search(t,k)
    * [ ] traverse - DFS
        * DFS
            * [ ] Iterative
            * [ ] Recursive
        * [ ] keysWithPrefix
        * [ ] longestPrefix

## Well sir, if I _had_ make a graph of understanding, it'd look like this.

You can view your understanding about a specific topic as a graph of
Comprehension vs. Time. At some magical threshold, you cross into Understanding.
But as time goes on, you begin to lose comprehension, because we forget things.
Each data point is everytime you actively recall this knowledge. If we had the
visualization, we could imagine these events plotted as circles, and the size of each
circle representing the effort you put into it, whether it be study or
application. The funny thing is, you only _know_ how much better your effort
made you _the next time you use it_. And then _that_ effort affects how you
are...it's mental exercise, no different.

But with this line graph, and its threshold of understanding, we can divide
learning into either 1) learning something _new_, or 2) reviewing something
_known_. Once you cross into understanding, it flips from new to known.

Is this simplification? Yes. It's a model. Is it _useful_? Better question.

### Testing belongs in both phases
Testing ourselves before we know something helps us learn faster and retain
longer, and testing ourselves afterwards is proven to be more effective than any
other form of review (re-reading, summarization, etc.).


Let's be smart about this, and apply learning tactics that're known to work:
Interleaving problems, testing, and spaced repetition.

* Interleaving
    * Categorize topics
    * Rotate through them
    * Should topics be interleaved when first learning them, or just during
      practice?
* Testing
    * Implementation
    * Practice problems
* Repetition
    * Initial: 30m-1h
    * Follow-up: 1w
* For learning data structures:
    * Test myself by doing an initial write-up of what I know. Write some code,
      if I feel up to it.
    * Start learning by reading through articles and books. Use this to flesh
      out the data structure or pseudo-code.
    * Test myself by going to implement the damn thing
    * Once implemented, schedule a review question in Anki for one week later.

1. Review (Known)
2. Interview Problem (New)
3. Study (New)
    1. Discovery (Finding resources, deconstructing the topic)
    2. Studying (Reading, watching, taking notes)
    3. Practicing (Applying; writing up DS || Algo w/ help)
    4. Archiving (Creating review notes)

2. Learn for 45m-1h new topic
    * Write-up notes in NWM
    * Apply SQ3R
    * Write code from examples
        * Schedule the worthwhile examples as review problems
3. Review problems from Anki until out of time.
